{% set class_name = model_name + "Resource" %}
{% set extra_operations = [] %}
{% set searchable_by_name = 'get%sList' % model_name in operations.keys() %}
{% set eligible_for_upsert = 'get%sList' % model_name in operations.keys() and 'edit%s' % model_name in operations.keys() and 'add%s' % model_name in operations.keys() %}
#!/usr/bin/python

# Copyright (c) 2018 Cisco Systems, Inc.
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)


{% include 'docs/base_docs.j2' %}

import json

from ansible.module_utils.basic import AnsibleModule, to_text
from ansible.module_utils.http import iterate_over_pageable_resource
from ansible.module_utils.misc import dict_subset, construct_module_result, copy_identity_properties
from ansible.module_utils.six.moves.urllib.error import HTTPError
from ansible.module_utils.connection import Connection


class {{ class_name }}(object):

    def __init__(self, conn):
        self._conn = conn
{# Method declarations for standard operations (CRUD) that are defined in Swagger documentation #}
{% for operation_name, operation_spec in operations.items() %}

    def {{ operation_name }}(self, params):
    {% if operation_spec.path_params %}
        path_params = dict_subset(params, [{{ operation_spec.path_params.keys() | sort | map('quote') | join(', ') }}])
    {% endif %}
    {% if operation_spec.query_params %}
        query_params = dict_subset(params, [{{ operation_spec.query_params.keys() | sort | map('quote') | join(', ') }}])
    {% endif %}
    {% if operation_spec.body_params %}
        body_params = dict_subset(params, [{{ operation_spec.body_params.keys() | sort | map('quote') | join(', ') }}])
    {% endif %}

        return self._conn.send_request(
            url_path={{ operation_spec.url_path | quote }},
            http_method={{ operation_spec.http_method | upper | quote }},
        {% if operation_spec.body_params %}
            body_params=body_params,
        {% endif %}
        {% if operation_spec.path_params %}
            path_params=path_params,
        {% endif %}
        {% if operation_spec.query_params %}
            query_params=query_params,
        {% endif %}
        )
{% endfor %}
{# Additional operation to search the object by name #}
{% if searchable_by_name %}
{% do extra_operations.append( "get"+model_name+"ByName" ) %}

    def get{{ model_name }}ByName(self, params):
        search_params = params.copy()
        search_params['filter'] = 'name:%s' % params['name']
        item_generator = iterate_over_pageable_resource(self.get{{ model_name }}List, search_params)
        return next((item for item in item_generator if item['name'] == params['name']), None)
{% endif %}
{# Additional operation to upsert the object (insert the new object or update if it already exists) #}
{% if eligible_for_upsert %}
{% do extra_operations.append( "upsert"+model_name ) %}

    def upsert{{ model_name }}(self, params):
        def is_duplicate_name_error(err):
            err_msg = to_text(err.read())
            return err.code == 422 and "Validation failed due to a duplicate name" in err_msg

        try:
            return self.add{{ model_name }}(params)
        except HTTPError as e:
            if is_duplicate_name_error(e):
                existing_object = self.get{{ model_name }}ByName(params)
                params = copy_identity_properties(existing_object, params)
                return self.edit{{ model_name }}(params)
            else:
                raise e
{% endif %}
{# Additional operation to edit the object by name #}
{% if searchable_by_name and 'edit%s' % model_name in operations.keys() %}
{% do extra_operations.append( "edit"+model_name+"ByName" ) %}

    def edit{{ model_name }}ByName(self, params):
        existing_object = self.get{{ model_name }}ByName(params)
        params = copy_identity_properties(existing_object, params)
        return self.edit{{ model_name }}(params)
{% endif %}
{# Additional operation to delete the object by name #}
{% if searchable_by_name and 'delete%s' % model_name in operations.keys() %}
{% do extra_operations.append( "delete"+model_name+"ByName" ) %}

    def delete{{ model_name }}ByName(self, params):
        existing_object = self.get{{ model_name }}ByName(params)
        params = copy_identity_properties(existing_object, params)
        return self.delete{{ model_name }}(params)
{% endif %}


def main():
    fields = dict(
    {% if eligible_for_upsert %}
        operation=dict(type='str', default='upsert{{ model_name }}', choices=[{{ operations | map('quote') | join(', ') }}{% if extra_operations %}, {{ extra_operations | map('quote') | join(', ') }}{% endif %}]),
    {% else %}
        operation=dict(type='str', choices=[{{ operations | map('quote') | join(', ') }}{% if extra_operations %}, {{ extra_operations | map('quote') | join(', ') }}{% endif %}], required=True),
    {% endif %}
        register_as=dict(type='str'),

    {% for param in params %}
        {{ param.name }}=dict(type={{ param.type | quote }}),
    {% endfor %}
    )

    module = AnsibleModule(argument_spec=fields)
    params = module.params

    try:
        conn = Connection(module._socket_path)
        resource = {{ class_name }}(conn)

        resource_method_to_call = getattr(resource, params['operation'])
        response = resource_method_to_call(params)

        result = construct_module_result(response, params)
        module.exit_json(**result)
    except HTTPError as e:
        err_msg = to_text(e.read())
        module.fail_json(changed=False, msg=json.loads(err_msg) if err_msg else {}, error_code=e.code)
    except Exception as e:
        module.fail_json(changed=False, msg=str(e))


if __name__ == '__main__':
    main()

