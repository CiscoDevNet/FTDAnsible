{% set class_name = model_name + "Resource" %}
{% set add_resource = operations['add' + model_name] %}
{% set get_resource = operations['get' + model_name] %}
#!/usr/bin/python

# Copyright (c) 2018 Cisco Systems, Inc.
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)


{% include 'docs/job_based_docs.j2' %}

import json

from ansible.module_utils.authorization import retry_on_token_expiration
from ansible.module_utils.basic import AnsibleModule, to_text
from ansible.module_utils.facts.timeout import TimeoutError
from ansible.module_utils.http import construct_url, base_headers, wait_for_job_completion, DEFAULT_TIMEOUT
{% if add_resource.body_params or add_resource.query_params %}
from ansible.module_utils.misc import dict_subset
{% endif %}
from ansible.module_utils.six.moves.urllib.error import HTTPError
from ansible.module_utils.urls import open_url


class {{ class_name }}(object):

    @staticmethod
    @retry_on_token_expiration
    def start_job(params):
{% if add_resource.query_params %}
        query_params = dict_subset(params, [{{ add_resource.query_params.keys() | map('quote') | join(', ') }}])
{% endif %}
{% if add_resource.body_params %}
        body_params = dict_subset(params, [{{ add_resource.body_params.keys() | map('quote') | join(', ') }}])
{% endif %}
        url = construct_url(params['hostname'], {{ add_resource.url_path | quote }}{% if add_resource.query_params %}, query_params=query_params{% endif %})
        response = open_url(url, method={{ add_resource.http_method | upper | quote }}, headers=base_headers(params['access_token']){% if add_resource.body_params %}, data=json.dumps(body_params){% endif %})
        return json.loads(to_text(response.read()))['id']

    @staticmethod
    @retry_on_token_expiration
    def fetch_job_status(params, job_id):
        url = construct_url(params['hostname'], {{ get_resource.url_path | quote }}, path_params={'objId': job_id})
        response = open_url(url, method={{ get_resource.http_method | upper | quote }}, headers=base_headers(params['access_token']))
        return json.loads(to_text(response.read()))


def main():
    fields = dict(
        hostname=dict(type='str', required=True),
        access_token=dict(type='str', required=True),
        refresh_token=dict(type='str', required=True),
        timeout=dict(type='int', default=DEFAULT_TIMEOUT),
{% for param in add_resource.body_params.values() %}
        {{ param.name }}=dict(type={{ param.type | quote }}),
{% endfor %}
{% for param in add_resource.query_params.values() %}
        {{ param.name }}=dict(type={{ param.type | quote }}),
{% endfor %}
    )

    module = AnsibleModule(argument_spec=fields)
    params = module.params

    try:
        job_id = {{ class_name }}.start_job(params)
        job_status = wait_for_job_completion(lambda: {{ class_name }}.fetch_job_status(params, job_id), params['timeout'])
        if job_status['state'] == 'DEPLOYED':
            module.exit_json(changed=True, status=job_status)
        else:
            module.fail_json(changed=False, msg="{{ model_name }} Failed", status=job_status)
    except TimeoutError:
        module.fail_json(changed=False, msg="{{ model_name }} Timeout. The job was not completed within the given time limits.")
    except HTTPError as e:
        err_msg = to_text(e.read())
        module.fail_json(changed=False, msg=json.loads(err_msg), error_code=e.code)


if __name__ == '__main__':
    main()

