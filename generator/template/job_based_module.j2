{% set class_name = model_name + "Resource" %}
{% set add_resource = operations['add' + model_name] %}
{% set get_resource = operations['get' + model_name] %}
#!/usr/bin/python

# Copyright (c) 2018 Cisco Systems, Inc.
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)


{% include 'docs/job_based_docs.j2' %}

import json

from ansible.module_utils.basic import AnsibleModule, to_text
from ansible.module_utils.connection import Connection
from ansible.module_utils.facts.timeout import TimeoutError
from ansible.module_utils.http import wait_for_job_completion, DEFAULT_TIMEOUT
{% if add_resource.body_params or add_resource.query_params %}
from ansible.module_utils.misc import dict_subset
{% endif %}
from ansible.module_utils.six.moves.urllib.error import HTTPError


class {{ class_name }}(object):

    def __init__(self, conn):
        self._conn = conn

    def start_job(self{% if add_resource.query_params or add_resource.body_params %}, params{% endif %}):
    {% if add_resource.query_params %}
        query_params = dict_subset(params, [{{ add_resource.query_params.keys() | map('quote') | join(', ') }}])
    {% endif %}
    {% if add_resource.body_params %}
        body_params = dict_subset(params, [{{ add_resource.body_params.keys() | map('quote') | join(', ') }}])
    {% endif %}
        return self._conn.send_request(
            url_path={{ add_resource.url_path | quote }},
            http_method={{ add_resource.http_method | upper | quote }},
        {% if add_resource.query_params %}
            query_params=query_params,
        {% endif %}
        {% if add_resource.body_params %}
            body_params=body_params,
        {% endif %}
        )['id']

    def fetch_job_status(self, job_id):
        return self._conn.send_request(
            url_path={{ get_resource.url_path | quote }},
            http_method={{ get_resource.http_method | upper | quote }},
            path_params={'objId': job_id}
        )


def main():
    fields = dict(
        timeout=dict(type='int', default=DEFAULT_TIMEOUT),
    {% for param in add_resource.body_params.values() %}
        {{ param.name }}=dict(type={{ param.type | quote }}),
    {% endfor %}
    {% for param in add_resource.query_params.values() %}
        {{ param.name }}=dict(type={{ param.type | quote }}),
    {% endfor %}
    )

    module = AnsibleModule(argument_spec=fields)
    params = module.params

    try:
        conn = Connection(module._socket_path)
        resource = {{ class_name }}(conn)

        job_id = resource.start_job({% if add_resource.query_params or add_resource.body_params %}params{% endif %})
        job_status = wait_for_job_completion(lambda: resource.fetch_job_status(job_id), params['timeout'])

        if job_status['state'] == 'DEPLOYED':
            module.exit_json(changed=True, status=job_status)
        else:
            module.fail_json(changed=False, msg="{{ model_name }} Failed", status=job_status)
    except TimeoutError:
        module.fail_json(changed=False, msg="{{ model_name }} Timeout. The job was not completed within the given time limits.")
    except HTTPError as e:
        err_msg = to_text(e.read())
        module.fail_json(changed=False, msg=json.loads(err_msg), error_code=e.code)


if __name__ == '__main__':
    main()

